% ÄŒlanek: Tight bounds for Classical Open Addressing
% Avtorji: Micheal A. Bender, William Kuszmaul, Renfei Zhou

The authors investigate the optimal tradeoff between time and space in classical open addressed hash tables with a high load factor of $1 - \epsilon$. They introduce the \textit{Rainbow Hash Table}, which achieves $O(1)$ expected query time and $O(\log\log(1/\epsilon))$ update time, while maintaining near-full hash table. They prove this tradeoff is optimal, demonstrating that no open-addressed hash table can achieve better time complexity while supporting such a high load factor.

Paper first introduced \textit{Rainbow Cell}, consisting of $n^{1/4}$ buckets, each containing $n^{3/4}$ slots of which $n^{1/2}$ slots are special \textit{sky slots}. Rainbow Cell is specialized hash table that operates at load factor of 1 with $O(1)$ time complexity for insertions and deletions, while queries have $O(n^{3/4})$ time complexity. Each element is randomly assigned either \textit{heavy} (high probability) or \textit{light} (low probability) state with status hash function. Heavy keys are stored only in bucket that it was hashed to. Light keys are stored only in sky slots and can be moved between buckets without disruption structure.

The idea is to reduce problem to subproblems and \textit{Rainbow Hash Table} is introduced. It is a tree structure where each subproblem is implemented as a Rainbow Cell. Elements are randomly assigned a color, which is used to help locate level of where element is going to end up. The probability distribution of colors ensures that most elements are placed in lower levels. Meaning, at lower levels of tree, subproblems become significantly smaller and tree becomes wider. 

Next, Rainbow Hash Table is extended to support dynamic resizing, meaning the hash table could increase and decrease in size while always remaining full (load factor of 1) and preserving its efficiency. Expected query time is $O(1)$ and expected update time of $O(\log\log n)$, where $n$ is current size of hash table. 

The final algorithm supports a load factor up to $1 - \epsilon$ and ensures insertions and deletions remain efficient. The last sections focus on their main result, proving the optimal time complexity for insertions and deletions in classical open addressing with a high load factor of $1 - \epsilon$ is $O(\log\log(1/\epsilon))$, while queries can be performed in $O(1)$. This result resolves the open question of whether it is possible to achieve operations with $O(1/\epsilon)$ time complexity for insertions, deletions, and queries simultaneously in an open-addressed hash table.