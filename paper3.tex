\subsection{Random walk d-ary cuckoo hashing}
Cuckoo hashing algorithm's basic idea is to resolve collisions by using two hash functions instead of one. When inserting a new object $x$ into the table, if the slot $h_1(x)$ is occupied, the existing object $x'$ is replaced by $x$, and then $x'$ is inserted into slot $h_2(x')$. If the number of iterations exceeds a threshold, the whole table is rehashed with new hash functions. Random Walk $d$-ary Cuckoo Hashing generalizes the idea by using $d$ hash functions and using a random walk to choose the next hash function in case of a collision. Standard cuckoo hashing, equivalent to the $d = 2$ case, has a load threshold of $0.5$, meaning it can use up to $50\%$ of the hash table space. The $d$-ary hashing improves this threshold. For example, the $d = 3$ case has the threshold at approximately $0.9$, while the insertion time increases linearly with $d$. The insertion algorithm guarantees $\mathcal{O}(1)$ lookup and deletion time, as the object can be retrieved by checking its $d$ positions.

\subsection{Insertion time}
This paper shows that for any $d \geq 4$ hashes and load factor $c < c*d$, the expectation of the random walk insertion time is constant. It shows that the expected number of reassignments during insertion does not depend on the size of the hash table $m$, but only on $d$ and $c$. The article uses bipartite graphs as a representation for the hash functions and objects. In the graph, the objects in set $X$ are connected to their $d$ possible locations in the hash table $Y$. In this representation, a valid perfect matching corresponds to a valid assignment of objects to slots. The existence of such a matching is subject to Hallâ€™s Theorem, which states that a perfect matching exists if and only if every subset $W \subseteq X$ is smaller than its neighborhood in $Y$. Neighborhood meaning all nodes connected to at least one vertex in $W$. The paper shows that when the load factor is below the threshold $c*d$, such perfect matchings exist with high probability as the graph exhibits strong expansion properties. The article identifies ``bad'' sets which have few connections to the rest of the graph. In these sets, the walk might get stuck, but the authors prove that the random walk is unlikely to hit such a set in the first $\mathcal{O}(i^{999})$ steps, and that any random walk which avoids it for the first $\mathcal{O}(i^{999})$ steps is likely to finish in $\mathcal{O}(i)$ steps.

\subsection{Super-polynomial tail bounds}
The paper also provides super-polynomial tail bounds on the insertion time, showing that the probability of a walk exceeding $\ell$ steps decays exponentially in $\ell$, with the exponent approaching $1$ as $d$ increases. They relate their findings to previous work on BFS-based insertion algorithms, noting that random walk insertion achieves comparable or better performance without the computational overhead of BFS path searches.